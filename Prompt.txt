You are an experienced backend and integration-focused professional software engineer.

ADVANCED API migration regression across three versions (v1→v2→v3):

**API Endpoints:**
* `/api/v1/orders` - deprecated (returns 410)
* `/api/v2/orders` - current, with `includeItems` gate
* `/api/v3/orders` - new version with breaking changes

**Key Schema Changes:**

| Aspect | v1 | v2 | v3 |
|--------|----|----|-----|
| Customer | `customerId`, `customerName` (flat) | `customer{id, name, email}` | `customer{id, name, email, address{...}, loyaltyTier}` |
| Price | `totalPrice` (float) | `amount{value, currency}` | `pricing{subtotal, tax, discount{...}, total, currency}` |
| Date | `createdAt` "YYYY-MM-DD" | `createdAt` ISO 8601 | `timestamps{created, updated, fulfilled}` |
| Status | `status` (enum: PAID/CANCELLED/SHIPPED) | `state` (adds FULFILLED) | `orderStatus{current, history[]}` |
| Items | `items[]{productName, qty}` | `lineItems[]{name, quantity, unitPrice, tax}` | `lineItems[]{id, name, quantity, pricing{...}, variant{...}, availability{...}}` |
| Errors | `{error, message}` | `{errors: [{code, message, field}]}` | `{errors: [...], requestId, timestamp, retryable}` |
| Pagination | None | `{data: [], total}` | `{data: [], pagination{...}, metadata{...}}` |

**Edge Cases:**
- v3: Multi-currency orders (need USD normalization)
- v3: Null vs missing field semantics
- v3: Conditional fields (shipment when SHIPPED, discount when applied)
- Array size limits (legacy crashes with >100 items)

**Legacy Client Assumptions:**
- `items` always exists and is non-empty
- `status`, `totalPrice` are primitives (string/float)
- `customerId`, `customerName` are flat fields
- `createdAt` is "YYYY-MM-DD"
- Enum values fixed, no pagination, single currency (USD)
- Non-200 from v1 = outage

**Hard Constraints:**
- CANNOT modify v2/v3 APIs or legacy clients
- MUST use compatibility layer (gateway/adapter)
- MUST support v2→v1 AND v3→v1 transformations
- MUST auto-detect source version

### Mandatory Deliverables

**1. Compatibility Mapping (with version auto-detection)**
   - `detect_version()`: Detect v2 vs v3 from response structure
   - `v2_to_legacy()`: Flatten customer, convert amount→totalPrice, ISO→YYYY-MM-DD, lineItems→items
   - `v3_to_legacy()`: Unwrap pagination, extract orderStatus.current→status, pricing→totalPrice (apply discount), timestamps.created→createdAt, flatten deeply nested structures
   - `to_legacy()`: Unified entry with auto-detection
   - Must be idempotent and handle null/missing fields

**2. Error Normalization**
   - v2 `{errors: [...]}` → v1 `{error, message}`
   - v3: Aggregate multiple errors, preserve retryable hint in message

**3. Three-Mode Testing (STRICT FAIL-THEN-PASS)**
   - **RAW_V2**: Tests MUST FAIL (show v2 breaks legacy)
   - **RAW_V3**: Tests MUST FAIL (show v3 additional breakage)
   - **COMPAT**: Same tests MUST PASS (mapping works)

**4. Response Classification**
   - DEPRECATED: v1 410 + API_VERSION_DEPRECATED
   - TRANSIENT: v3 with retryable=true
   - CLIENT_ERROR: 4xx
   - OUTAGE: 5xx (non-retryable)
   - OK: 2xx

**5. Test Runner Script**
   - `run_tests.ps1`: Run all three modes sequentially
   - Print pass/fail for each mode with statistics
   - Exit non-zero if gate not satisfied
   - Generate JSON test report

**6. Environment Files**
   - `requirements.txt`: Minimal pinned deps
   - `requirements-dev.txt`: Test deps

**7. README**
   - Schema evolution summary (v1→v2→v3)
   - Breaking changes and why they break
   - Compatibility strategy
   - How to run tests and interpret output

### Implementation Note

Use the provided starter script as the test harness. You must implement the TODO sections:
1. `request_json()` - HTTP client with retry logic and timeout handling
2. `detect_version()` - Auto-detect source API version from response structure
3. `v2_to_legacy()` - v2-specific mapping rules
4. `v3_to_legacy()` - v3-specific mapping rules with advanced transformations
5. `to_legacy()` - Unified entry point that auto-detects version and routes appropriately
6. `classify_response()` - Extended monitoring semantics with severity levels
7. `normalize_error_response()` - Handle v2/v3 error formats with aggregation
8. `validate_idempotency()` - Ensure transformations are idempotent
9. `benchmark_transformation()` - Measure transformation performance

You must make the COMPAT mode pass ALL checks for BOTH v2 and v3 sources.
You must demonstrate clear failures in RAW_V2 and RAW_V3 modes.
You must keep output technically precise and directly runnable.
The solution must be production-ready with proper error handling and edge case coverage.

### Implementation Tasks

Implement 9 TODO functions in the test harness:
1. `request_json()`: HTTP client with retry logic (3 retries, exponential backoff)
2. `detect_version()`: Auto-detect v2 vs v3 from response structure
3. `v2_to_legacy()`: v2→v1 mapping
4. `v3_to_legacy()`: v3→v1 advanced mapping
5. `to_legacy()`: Unified entry point
6. `classify_response()`: Extended monitoring (5 severity levels)
7. `normalize_error_response()`: Error aggregation
8. `validate_idempotency()`: Ensure transformations are idempotent
9. `benchmark_transformation()`: Measure performance

### Quality Requirements

- **COMPAT mode**: 100% pass rate
- **RAW_V2/RAW_V3 modes**: Designed-to-fail tests must fail
- **Idempotency**: Applying transformation twice = same result
- **Performance**: <10ms per transformation (50 line items), <500ms batch (100 orders)
- **Thread safety**: Must support concurrent transformations
- **Code quality**: Type hints, docstrings, no TODO comments in production code

